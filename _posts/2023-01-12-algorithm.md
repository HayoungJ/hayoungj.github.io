---
layout: post
title: '알고리즘'
subtitle: '누구나 자료구조와 알고리즘 (개정2판)'
date: 2023-01-12
background: '/img/posts/02.jpg'
---

<blockquote class="blockquote">
  아래 내용은 길벗 출판사의
  <strong>누구나 자료구조와 알고리즘 개정 2판, 제이 웬그로우 지음</strong>을
  공부하며 정리한 내용입니다.
</blockquote>

<h2 class="section-heading">알고리즘</h2>

<p>
  자료구조가 이미 결정되어 있더라도, 사용하는 알고리즘에 따라 코드의 효율성이
  달라진다<br />
  알고리즘은 어떤 과제를 완수하는 명령어 집합이라고 정의할 수 있는데, 같은
  과제라도 다른 알고리즘을 사용해 해결할 수 있다.
</p>

<h2 class="section-heading">정렬된 배열</h2>

<p>
  정렬된 배열은, 전형적인 배열과 거의 같지만 값들을 항상 순서대로 담고있는
  배열이다. 정렬된 배열은 삽입 시 값을 적절한 셀에 넣어 값을 정렬된 상태로
  유지한다. 다시 말해, 한 단계만에 삽입을 완료할 수 있는 전형적인 배열과 다르게,
  '해당 값이 들어갈 올바른 자리를 탐색하고' '’'해당 자리에 값이 들어갈 수 있도록
  다른 요소들을 이동하는' 단계가 추가되는 것이다.
</p>

<p>
  정렬된 배열의 삽입에서 흥미로운 점은, 새 값이 어느 위치에 들어가건 삽입에
  필요한 총 단계 수는 비슷하다는 점이다. 새 값이 앞 쪽에 들어가게 될 경우, 탐색
  단계는 줄어들고 이동 단계는 늘어난다. 반대로 새 값이 뒤 쪽에 들어가게 될 경우,
  탐색 단계는 늘어나고 이동 단계는 줄어든다. 최상의 경우는 맨 뒤 쪽에 들어가는
  경우로, 탐색에 N단계와 삽입에 1단계를 사용해 총 N+1단계가 필요하다. 맨 뒤 쪽에
  들어가는 경우를 제외하고는, 총 N+2단계를 거쳐야한다.
</p>

<p class="comment">
  n번째 위치에 들어간다면, 탐색 시 기존 배열의 n번째 원소까지 확인한 뒤 ‘이
  자리의 값을 뒤로 밀어내고 새 값을 넣으면 되는구나’ 하고 알게 되는 것이기
  때문에 탐색에 n단계가 필요하다. 이때 해당 자리를 기준으로 앞에는 원소가 n-1개,
  뒤에는 N-(n-1)개 존재하기 때문에 이동에는 N-(n-1) = N-n+1 단계, 삽입에 1단계라
  총 N+2단계가 필요하다.
</p>

<h3>강력한 검색</h3>

<p>
  정렬된 배열의 장점은 검색에 있다. 정렬되지 않은 배열의 경우, 찾고자 하는 값이
  배열의 어디에나 있을 수 있기 때문에 배열 전체를 탐색해야한다. 배열의 끝까지
  탐색하지 않아도 되는 경우는, 원하는 값을 중간에 찾았을 경우 뿐이다.<br />
  반면 정렬된 배열에서는, 찾고자 하는 값이 배열 안에 존재하지 않을 때 (그렇지
  않은 배열과 비교해) 더 빠르게 검색을 중단할 수 있다. 예를 들어, [3, 17, 75,
  80, 202]라는 정렬된 배열 안에서 ‘22’를 찾을 때, 75에 도달하면 더 이상 오른쪽에
  22가 존재하는 것이 불가능하다고 판단하고 검색을 종료할 수 있다.<br />
</p>

<p>
  이렇게 선형 검색을 하는 경우, 정렬된 배열과 그렇지 않은 배열 간의 효율성은
  특정 상황을 제외하고는 크게 차이가 나지 않는다. 정렬된 배열의 경우도, 찾고자
  하는 값이 배열의 마지막에 위치하거나 배열의 마지막 값보다 크다면 배열 전체를
  탐색해야만 검색을 종료할 수 있다. 적어도, 최악의 경우는 일반적인 배열과 다르지
  않은 것이다. 그렇지만 정렬된 배열의 검색에는, 선형 검색보다 훨씬
  효율적인(빠른) 다른 검색 알고리즘도 사용할 수 있다.
</p>

<h3>이진검색</h3>

<p>
  이진 검색은 주어진 값들 중 중간을 고른 후, 해당 값을 기준으로 크고 작음을
  비교해 값들 중 절반 씩을 계속해서 제거해나가는 검색 방법이다. 예를 들어, 1부터
  10까지의 자연수가 하나씩 들어있는 경우라면, <br />
  1. 10의 절반인 5부터 시작<br />
  2. 찾고자 하는 값이 5보다 클 경우 1~5까지의 수는 탐색의 후보에서 제외<br />
  3. 6~10까지에 대해 같은 과정을 반복한다.<br />
  이진 검색은 정렬된 배열에서만 사용할 수 있는데, 정렬되지 않은 경우라면 찾고자
  하는 값이 지금 확인한 값의 왼쪽에 있을지 오른쪽에 있을지 판단할 수 없기
  때문이다.
</p>

```
배열 array와 찾고자 하는 값 value를 입력 받음
배열의 길이 N을 구함
lowerBound = 0
upperBound = N-1
while upperBound >= lowerBound
  (lowerBound + upperBound) / 2를 버림한 값을 midPoint로 설정
  if 배열[midPoint]에 해당하는 값 === value
    midPoint를 리턴 후 종료
  else if 배열[midPoint]에 해당하는 값 > value
    midPoint-1을 upperBound로 설정
  else if 배열[midPoint]에 해당하는 값 < value
    midPoint+1을 lowerBound로 설정
null을 리턴 후 종료
```

<span class="caption">마지막 else-if의 경우 else를 사용해도 되지만, 명확한 조건 확인을 위해 else-if를 사용하였다.</span>
