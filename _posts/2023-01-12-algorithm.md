---
layout: post
title: '알고리즘'
subtitle: '누구나 자료구조와 알고리즘 (개정2판)'
date: 2023-01-12
update: 2023-01-13
background: '/img/posts/02.jpg'
use_math: true
---

<blockquote class="blockquote">
  아래 내용은 길벗 출판사의
  <strong>누구나 자료구조와 알고리즘 개정 2판, 제이 웬그로우 지음</strong>을
  공부하며 정리한 내용입니다.
</blockquote>

<h2 class="section-heading">알고리즘</h2>

<p>
  자료구조가 이미 결정되어 있더라도, 사용하는 알고리즘에 따라 코드의 효율성이
  달라진다<br />
  알고리즘은 어떤 과제를 완수하는 명령어 집합이라고 정의할 수 있는데, 같은
  과제라도 다른 알고리즘을 사용해 해결할 수 있다.
</p>

<h2 class="section-heading">정렬된 배열</h2>

<p>
  정렬된 배열은, 전형적인 배열과 거의 같지만 값들을 항상 순서대로 담고있는
  배열이다. 정렬된 배열은 삽입 시 값을 적절한 셀에 넣어 값을 정렬된 상태로
  유지한다. 다시 말해, 한 단계만에 삽입을 완료할 수 있는 전형적인 배열과 다르게,
  '해당 값이 들어갈 올바른 자리를 탐색하고' '’'해당 자리에 값이 들어갈 수 있도록
  다른 요소들을 이동하는' 단계가 추가되는 것이다.
</p>

<p>
  정렬된 배열의 삽입에서 흥미로운 점은, 새 값이 어느 위치에 들어가건 삽입에
  필요한 총 단계 수는 비슷하다는 점이다. 새 값이 앞 쪽에 들어가게 될 경우, 탐색
  단계는 줄어들고 이동 단계는 늘어난다. 반대로 새 값이 뒤 쪽에 들어가게 될 경우,
  탐색 단계는 늘어나고 이동 단계는 줄어든다. 최상의 경우는 맨 뒤 쪽에 들어가는
  경우로, 탐색에 N단계와 삽입에 1단계를 사용해 총 N+1단계가 필요하다. 맨 뒤 쪽에
  들어가는 경우를 제외하고는, 총 N+2단계를 거쳐야한다.
</p>

<p class="comment">
  n번째 위치에 들어간다면, 탐색 시 기존 배열의 n번째 원소까지 확인한 뒤 ‘이
  자리의 값을 뒤로 밀어내고 새 값을 넣으면 되는구나’ 하고 알게 되는 것이기
  때문에 탐색에 n단계가 필요하다. 이때 해당 자리를 기준으로 앞에는 원소가 n-1개,
  뒤에는 N-(n-1)개 존재하기 때문에 이동에는 N-(n-1) = N-n+1 단계, 삽입에 1단계라
  총 N+2단계가 필요하다.
</p>

<h3>강력한 검색</h3>

<p>
  정렬된 배열의 장점은 검색에 있다. 정렬되지 않은 배열의 경우, 찾고자 하는 값이
  배열의 어디에나 있을 수 있기 때문에 배열 전체를 탐색해야한다. 배열의 끝까지
  탐색하지 않아도 되는 경우는, 원하는 값을 중간에 찾았을 경우 뿐이다.<br />
  반면 정렬된 배열에서는, 찾고자 하는 값이 배열 안에 존재하지 않을 때 (그렇지
  않은 배열과 비교해) 더 빠르게 검색을 중단할 수 있다. 예를 들어, [3, 17, 75,
  80, 202]라는 정렬된 배열 안에서 ‘22’를 찾을 때, 75에 도달하면 더 이상 오른쪽에
  22가 존재하는 것이 불가능하다고 판단하고 검색을 종료할 수 있다.<br />
</p>

<p>
  이렇게 선형 검색을 하는 경우, 정렬된 배열과 그렇지 않은 배열 간의 효율성은
  특정 상황을 제외하고는 크게 차이가 나지 않는다. 정렬된 배열의 경우도, 찾고자
  하는 값이 배열의 마지막에 위치하거나 배열의 마지막 값보다 크다면 배열 전체를
  탐색해야만 검색을 종료할 수 있다. 적어도, 최악의 경우는 일반적인 배열과 다르지
  않은 것이다. 그렇지만 정렬된 배열의 검색에는, 선형 검색보다 훨씬
  효율적인(빠른) 다른 검색 알고리즘도 사용할 수 있다.
</p>

<h3>이진검색</h3>

<p>
  이진 검색은 주어진 값들 중 중간을 고른 후, 해당 값을 기준으로 크고 작음을
  비교해 값들 중 절반 씩을 계속해서 제거해나가는 검색 방법이다. 예를 들어, 1부터
  10까지의 자연수가 하나씩 들어있는 경우라면, <br />
  1. 10의 절반인 5부터 시작<br />
  2. 찾고자 하는 값이 5보다 클 경우 1~5까지의 수는 탐색의 후보에서 제외<br />
  3. 6~10까지에 대해 같은 과정을 반복한다.<br />
  이진 검색은 정렬된 배열에서만 사용할 수 있는데, 정렬되지 않은 경우라면 찾고자
  하는 값이 지금 확인한 값의 왼쪽에 있을지 오른쪽에 있을지 판단할 수 없기
  때문이다.
</p>

```
배열 array와 찾고자 하는 값 value를 입력 받음
배열의 길이 N을 구함
lowerBound = 0
upperBound = N-1
while upperBound >= lowerBound
  (lowerBound + upperBound) / 2를 버림한 값을 midPoint로 설정
  if 배열[midPoint] === value
    midPoint를 리턴 후 종료
  else if 배열[midPoint] > value
    midPoint-1을 upperBound로 설정
  else if 배열[midPoint] < value
    midPoint+1을 lowerBound로 설정
null을 리턴 후 종료
```

<span class="caption">마지막 else-if의 경우 else를 사용해도 되지만, 명확한 조건 확인을 위해 else-if를 사용하였다.</span>

<p>
작은 크기의 정렬된 배열이라면 이진 검색의 효율성과 선형 검색의 효율성이 비슷하다. 하지만 배열의 더 커지면, 이진 검색 알고리즘의 효율성이 드러난다. 100개의 값을 갖는 정렬된 배열에서 선형 검색의 최대 단계 수는 100단계이지만, 이진 검색의 경우는 7단계에 불과하다. 10000개의 값이 있다면, 선형 검색의 최대 단계 수는 10000단계이지만 이진 검색의 경우는 최악의 경우에도 13단계만 거치면 된다. 선형 검색이 배열의 크기가 두 배가 될 떄마다 필요한 단계 수도 두 배로 늘어나는 것에 비해, 이진 검색은 배열의 크기가 두 배가 될 때마다 한 단계 씩 더 소요되기 때문에 대단히 효율적이라고 할 수 있다.
</p>

<p>
이진 검색을 사용해 정렬된 배열의 검색을 더 효율적으로 할 수 있다는 것은, 삽입에 필요한 단계 수를 줄일 수 있다는 말이기도 하다. 정렬된 배열의 삽입 전에는 검색하는 과정이 필요한데, 그 과정을 단축할 수 있다는 의미이기 때문이다. 다만 일반 배열의 경우 삽입 전에 검색이 아예 필요하지 않으므로, 여전히 삽입 속도는 일반 배열이 더 빠르다.<br>
정렬된 배열은 일반적인 배열보다 삽입은 더 오래 걸리지만, 검색은 훨씬 빠르다. 그렇기 때문에 사용자의 애플리케이션에 어떤 구조가 더 필요할지를 항상 분석해야 한다. 모든 상황에 완벽하게 들어맞는 단 하나의 자료구조나 알고리즘은 거의 없기 때문에, 각 방식의 성능을 비교할 수 있는 공통 언어가 있다면 더 나은 결정을 내릴 수 있는 정보를 명확하게 전달할 수 있다.
</p>

<h3>연습문제</h3>

<p>
  <strong>1. 정렬된 배열 [2, 4, 6, 8, 10, 12, 13]에서 선형 검색으로 숫자 8을 찾는 데 몇 단계가 걸릴까?</strong><br>
  2, 4, 6, 8까지 조회하고 종료되므로, 총 4단계<br>
  <br>
  <strong>2. 이진 검색으로 1번 문제를 풀면 몇 단계가 걸릴까?</strong><br>
  크기가 7인 배열의 중간값은 4번째에 위치한 요소이고, 해당 값이 곧 8이므로, 총 1단계<br>
  <br>
  <strong>3. 크기가 100,000인 배열에는 이진 검색에 최대 몇 단계가 걸릴까?</strong><br>
  이진 검색에 필요한 최대 단계 수는, 배열의 크기 / $2^n$을 버림한 값이 1이 될 때까지 n을 1씩 늘려가며 더해서 구할 수 있다. 이를 수식으로 적으면, <br>
  $1 \leq \frac{N}{2^n} < 2$<br>
  $2^n \leq N < 2^{n+1}$<br>
  $n \leq log_2 N < n+1$<br>
  이므로 $log_2 N$값을 버림하면 된다는 것을 알 수 있다. $log_2 100000$은 약 16.6이므로, $n$은 16이다.<br>
</p>
